import { createContext, useContext, useState, useRef, useCallback, useEffect } from 'react';
import io from 'socket.io-client';
import ENV from '../config/env';
import {
  initializeDevice,
  createSendTransport,
  createRecvTransport,
  produceVideo,
  produceAudio,
  consumeProducer,
  closeProducer,
  closeConsumer,
  closeTransport
} from '../utils/mediasoup';

/**
 * WebRTC Context - MediaSoup SFU Architecture
 * 
 * Architecture:
 * - Gateway as SFU (Selective Forwarding Unit)
 * - MediaSoup client for WebRTC
 * - Socket.IO for signaling
 * - Send/Recv transports for media
 * - Producer/Consumer model
 */

const WebRTCContext = createContext(null);

export const useWebRTC = () => {
  const context = useContext(WebRTCContext);
  if (!context) {
    throw new Error('useWebRTC must be used within WebRTCProvider');
  }
  return context;
};

export const WebRTCProvider = ({ children }) => {
  // ==========================================
  // STATE
  // ==========================================
  
  const [socket, setSocket] = useState(null);
  const [roomId, setRoomId] = useState(null);
  const [userId, setUserId] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  
  // Media streams
  const [localStream, setLocalStream] = useState(null);
  const [remoteStreams, setRemoteStreams] = useState(new Map()); // participantId -> MediaStream
  
  // Connection state
  const [connectionState, setConnectionState] = useState('new');
  
  // Participants (Map: participantId -> {username, ...})
  const [participants, setParticipants] = useState(new Map());
  
  // Translation settings
  const [sourceLanguage, setSourceLanguage] = useState('vi');
  const [targetLanguage, setTargetLanguage] = useState('en');
  
  // Transcriptions
  const [transcriptions, setTranscriptions] = useState([]);
  
  // ==========================================
  // REFS - MediaSoup Objects
  // ==========================================
  
  const deviceRef = useRef(null);
  const sendTransportRef = useRef(null);
  const recvTransportRef = useRef(null);
  
  const localStreamRef = useRef(null);
  const videoProducerRef = useRef(null);
  const audioProducerRef = useRef(null);
  
  // Map: participantId -> { video: Consumer, audio: Consumer }
  const consumersRef = useRef(new Map());
  
  // ==========================================
  // SOCKET INITIALIZATION
  // ==========================================
  
  const initializeSocket = useCallback(() => {
    const GATEWAY_URL = ENV.GATEWAY_URL;
    
    console.log('ðŸ”Œ Connecting to Gateway SFU:', GATEWAY_URL);
    
    const newSocket = io(GATEWAY_URL, {
      transports: ['websocket', 'polling'],
      upgrade: true,
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 5,
      timeout: 20000
    });
    
    newSocket.on('connect', () => {
      console.log('âœ… Socket connected:', newSocket.id);
      setIsConnected(true);
      setUserId(newSocket.id);
    });
    
    newSocket.on('disconnect', () => {
      console.log('âŒ Socket disconnected');
      setIsConnected(false);
      setConnectionState('disconnected');
    });
    
    newSocket.on('connect_error', (error) => {
      console.error('ðŸ”´ Socket connection error:', error);
      setConnectionState('failed');
    });
    
    // Room events
    newSocket.on('joined', (data) => {
      console.log('âœ… Joined room:', data);
      const { participants: participantsList } = data;
      
      // Convert participants array to Map
      const participantsMap = new Map();
      if (Array.isArray(participantsList)) {
        participantsList.forEach(p => {
          participantsMap.set(p.id, {
            username: p.username || p.id,
            sourceLanguage: p.sourceLanguage || 'vi',
            targetLanguage: p.targetLanguage || 'en'
          });
        });
      }
      setParticipants(participantsMap);
    });
    
    newSocket.on('participant-joined', (data) => {
      console.log('ðŸ‘¤ Participant joined:', data);
      const { participantId, username } = data;
      
      setParticipants(prev => {
        const newMap = new Map(prev);
        newMap.set(participantId, {
          username: username || participantId,
          sourceLanguage: 'vi',
          targetLanguage: 'en'
        });
        return newMap;
      });
    });
    
    newSocket.on('participant-left', (data) => {
      console.log('ðŸ‘‹ Participant left:', data);
      const { participantId } = data;
      
      // Close consumers for this participant
      const userConsumers = consumersRef.current.get(participantId);
      if (userConsumers) {
        Object.values(userConsumers).forEach(consumer => {
          if (consumer) closeConsumer(consumer);
        });
        consumersRef.current.delete(participantId);
      }
      
      // Remove remote stream
      setRemoteStreams(prev => {
        const newMap = new Map(prev);
        newMap.delete(participantId);
        return newMap;
      });
      
      // Remove from participants
      setParticipants(prev => {
        const newMap = new Map(prev);
        newMap.delete(participantId);
        return newMap;
      });
    });
    
    // MediaSoup events
    newSocket.on('new-producer', async (data) => {
      console.log('ðŸŽ¥ New producer:', data);
      const { producerId, producerSocketId, kind } = data;
      
      // Skip own producers
      if (producerSocketId === newSocket.id) {
        console.log('â­ï¸  Skipping own producer');
        return;
      }
      
      try {
        await consumeRemoteProducer(producerId, producerSocketId, kind, newSocket);
      } catch (error) {
        console.error('âŒ Failed to consume new producer:', error);
      }
    });
    
    newSocket.on('producer-closed', (data) => {
      console.log('ðŸš« Producer closed:', data);
      const { producerId } = data;
      
      // Find and close consumer
      consumersRef.current.forEach((userConsumers, participantId) => {
        Object.entries(userConsumers).forEach(([kind, consumer]) => {
          if (consumer && consumer.id === producerId) {
            closeConsumer(consumer);
            delete userConsumers[kind];
            
            // Update remote stream
            setRemoteStreams(prev => {
              const newMap = new Map(prev);
              const stream = newMap.get(participantId);
              if (stream && consumer.track) {
                stream.removeTrack(consumer.track);
              }
              return newMap;
            });
          }
        });
      });
    });
    
    // Translation events
    newSocket.on('transcription', (data) => {
      console.log('ðŸ“ Transcription:', data);
      setTranscriptions(prev => [...prev, data]);
    });
    
    setSocket(newSocket);
    return newSocket;
  }, []);
  
  // ==========================================
  // MEDIASOUP INITIALIZATION
  // ==========================================
  
  const initializeMediaSoup = useCallback(async (socketInstance) => {
    if (!socketInstance || !roomId) {
      throw new Error('Socket or roomId not available');
    }
    
    try {
      console.log('ðŸŽ¬ Initializing MediaSoup...');
      
      // Get router RTP capabilities
      const rtpCapabilities = await new Promise((resolve, reject) => {
        socketInstance.emit('get-rtp-capabilities', { roomId }, (response) => {
          if (response?.error) {
            reject(new Error(response.error.message || 'Failed to get RTP capabilities'));
          } else {
            resolve(response.rtpCapabilities);
          }
        });
      });
      
      console.log('âœ… Got RTP capabilities');
      
      // Initialize device
      const device = await initializeDevice(rtpCapabilities);
      deviceRef.current = device;
      
      // Create transports
      const transports = await createTransports(device, socketInstance);
      
      console.log('âœ… MediaSoup initialized');
      setConnectionState('connected');
      
      return transports;
    } catch (error) {
      console.error('âŒ MediaSoup initialization failed:', error);
      setConnectionState('failed');
      throw error;
    }
  }, [roomId]);
  
  const createTransports = useCallback(async (device, socketInstance) => {
    if (!roomId) throw new Error('Room ID not set');
    
    // Create send transport
    const sendTransportParams = await new Promise((resolve, reject) => {
      socketInstance.emit('create-webrtc-transport', {
        roomId,
        producing: true,
        consuming: false
      }, (response) => {
        if (response?.error) {
          reject(new Error(response.error.message || 'Failed to create send transport'));
        } else {
          resolve(response);
        }
      });
    });
    
    const sendTransport = createSendTransport(device, sendTransportParams, socketInstance, roomId);
    sendTransportRef.current = sendTransport;
    console.log('âœ… Send transport created');
    
    // Create receive transport
    const recvTransportParams = await new Promise((resolve, reject) => {
      socketInstance.emit('create-webrtc-transport', {
        roomId,
        producing: false,
        consuming: true
      }, (response) => {
        if (response?.error) {
          reject(new Error(response.error.message || 'Failed to create recv transport'));
        } else {
          resolve(response);
        }
      });
    });
    
    const recvTransport = createRecvTransport(device, recvTransportParams, socketInstance, roomId);
    recvTransportRef.current = recvTransport;
    console.log('âœ… Recv transport created');
    
    return { sendTransport, recvTransport };
  }, [roomId]);
  
  // ==========================================
  // MEDIA CAPTURE
  // ==========================================
  
  const getLocalStream = useCallback(async (constraints = {}) => {
    try {
      const defaultConstraints = {
        video: {
          width: { ideal: 1280, max: 1920 },
          height: { ideal: 720, max: 1080 },
          frameRate: { ideal: 30, max: 60 }
        },
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        }
      };
      
      const stream = await navigator.mediaDevices.getUserMedia({
        ...defaultConstraints,
        ...constraints
      });
      
      console.log('âœ… Got local stream:', stream.id);
      localStreamRef.current = stream;
      setLocalStream(stream);
      
      return stream;
    } catch (error) {
      console.error('âŒ Error getting local stream:', error);
      throw error;
    }
  }, []);
  
  // ==========================================
  // PRODUCE MEDIA
  // ==========================================
  
  const startProducing = useCallback(async (stream) => {
    if (!sendTransportRef.current || !deviceRef.current) {
      throw new Error('Transport or device not ready');
    }
    
    try {
      const videoTrack = stream.getVideoTracks()[0];
      const audioTrack = stream.getAudioTracks()[0];
      
      if (videoTrack) {
        const videoProducer = await produceVideo(
          sendTransportRef.current,
          videoTrack,
          deviceRef.current
        );
        videoProducerRef.current = videoProducer;
        console.log('âœ… Started producing video');
      }
      
      if (audioTrack) {
        const audioProducer = await produceAudio(
          sendTransportRef.current,
          audioTrack
        );
        audioProducerRef.current = audioProducer;
        console.log('âœ… Started producing audio');
      }
    } catch (error) {
      console.error('âŒ Error starting production:', error);
      throw error;
    }
  }, []);
  
  // ==========================================
  // CONSUME MEDIA
  // ==========================================
  
  const consumeRemoteProducer = useCallback(async (producerId, participantId, kind, socketInstance) => {
    if (!recvTransportRef.current || !deviceRef.current) {
      console.warn('âš ï¸ Cannot consume: transport or device not ready');
      return;
    }
    
    try {
      const { consumer } = await consumeProducer(
        recvTransportRef.current,
        deviceRef.current,
        socketInstance,
        roomId,
        producerId,
        participantId
      );
      
      // Store consumer
      if (!consumersRef.current.has(participantId)) {
        consumersRef.current.set(participantId, {});
      }
      consumersRef.current.get(participantId)[kind] = consumer;
      
      // Add track to remote stream
      setRemoteStreams(prev => {
        const newMap = new Map(prev);
        let stream = newMap.get(participantId);
        
        if (!stream) {
          stream = new MediaStream();
          newMap.set(participantId, stream);
        }
        
        // Remove old track of same kind
        stream.getTracks().forEach(track => {
          if (track.kind === kind) {
            stream.removeTrack(track);
          }
        });
        
        // Add new track
        stream.addTrack(consumer.track);
        
        return newMap;
      });
      
      console.log(`âœ… Consuming ${kind} from ${participantId}`);
    } catch (error) {
      console.error(`âŒ Failed to consume ${kind}:`, error);
    }
  }, [roomId]);
  
  // ==========================================
  // ROOM OPERATIONS
  // ==========================================
  
  const createRoom = useCallback(async () => {
    if (!socket || !socket.connected) {
      throw new Error('Socket not connected');
    }
    
    console.log('ðŸ”¨ Creating new room...');
    
    return new Promise((resolve, reject) => {
      socket.emit('create-room', (response) => {
        if (response?.error) {
          console.error('âŒ Create room error:', response.error);
          reject(new Error(response.error.message || 'Failed to create room'));
        } else if (!response?.roomId) {
          reject(new Error('Create room response missing roomId'));
        } else {
          console.log('âœ… Room created:', response.roomId);
          resolve(response.roomId);
        }
      });
    });
  }, [socket]);
  
  const joinRoom = useCallback(async (roomIdToJoin, userInfo = {}) => {
    try {
      if (!socket || !socket.connected) {
        throw new Error('Socket not connected');
      }
      
      console.log('ðŸšª Joining room:', roomIdToJoin);
      setRoomId(roomIdToJoin);
      
      // Get local media first
      const stream = await getLocalStream();
      
      // Join room via socket
      await new Promise((resolve, reject) => {
        socket.emit('join-room', {
          roomId: roomIdToJoin,
          name: userInfo.username || userId || 'User',
          sourceLanguage,
          targetLanguage
        }, (response) => {
          if (response?.error) {
            reject(new Error(response.error.message || 'Failed to join room'));
          } else {
            resolve(response);
          }
        });
      });
      
      // Initialize MediaSoup
      await initializeMediaSoup(socket);
      
      // Start producing
      await startProducing(stream);
      
      console.log('âœ… Successfully joined room');
    } catch (error) {
      console.error('âŒ Error joining room:', error);
      setConnectionState('failed');
      throw error;
    }
  }, [socket, userId, sourceLanguage, targetLanguage, getLocalStream, initializeMediaSoup, startProducing]);
  
  const leaveRoom = useCallback(() => {
    console.log('ðŸ‘‹ Leaving room');
    
    // Close producers
    if (videoProducerRef.current) closeProducer(videoProducerRef.current);
    if (audioProducerRef.current) closeProducer(audioProducerRef.current);
    
    // Close consumers
    consumersRef.current.forEach((userConsumers) => {
      Object.values(userConsumers).forEach(consumer => {
        if (consumer) closeConsumer(consumer);
      });
    });
    consumersRef.current.clear();
    
    // Close transports
    if (sendTransportRef.current) closeTransport(sendTransportRef.current);
    if (recvTransportRef.current) closeTransport(recvTransportRef.current);
    
    // Stop local stream
    if (localStreamRef.current) {
      localStreamRef.current.getTracks().forEach(track => track.stop());
      localStreamRef.current = null;
    }
    
    // Emit leave event
    if (socket && roomId) {
      socket.emit('leave-room', { roomId, userId });
    }
    
    // Clear state
    setRoomId(null);
    setLocalStream(null);
    setRemoteStreams(new Map());
    setParticipants(new Map());
    setConnectionState('new');
    
    console.log('âœ… Left room');
  }, [socket, roomId, userId]);
  
  // ==========================================
  // MEDIA CONTROLS
  // ==========================================
  
  const toggleAudio = useCallback(() => {
    if (localStreamRef.current) {
      const audioTrack = localStreamRef.current.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        
        // Pause/Resume producer
        if (audioProducerRef.current) {
          if (audioTrack.enabled) {
            audioProducerRef.current.resume();
          } else {
            audioProducerRef.current.pause();
          }
        }
        
        return audioTrack.enabled;
      }
    }
    return false;
  }, []);
  
  const toggleVideo = useCallback(() => {
    if (localStreamRef.current) {
      const videoTrack = localStreamRef.current.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled;
        
        // Pause/Resume producer
        if (videoProducerRef.current) {
          if (videoTrack.enabled) {
            videoProducerRef.current.resume();
          } else {
            videoProducerRef.current.pause();
          }
        }
        
        return videoTrack.enabled;
      }
    }
    return false;
  }, []);
  
  // ==========================================
  // LIFECYCLE
  // ==========================================
  
  useEffect(() => {
    const newSocket = initializeSocket();
    
    return () => {
      leaveRoom();
      newSocket?.disconnect();
    };
  }, []);
  
  // ==========================================
  // CONTEXT VALUE
  // ==========================================
  
  const value = {
    // Connection
    socket,
    isConnected,
    userId,
    connectionState,
    
    // Room
    roomId,
    participants,
    createRoom,
    joinRoom,
    leaveRoom,
    
    // Media
    localStream,
    remoteStreams,
    getLocalStream,
    
    // Controls
    toggleAudio,
    toggleVideo,
    
    // Translation
    sourceLanguage,
    targetLanguage,
    setSourceLanguage,
    setTargetLanguage,
    transcriptions
  };
  
  return (
    <WebRTCContext.Provider value={value}>
      {children}
    </WebRTCContext.Provider>
  );
};

export default WebRTCContext;
