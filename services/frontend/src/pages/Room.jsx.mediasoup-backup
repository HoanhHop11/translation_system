import { useEffect, useState, useRef } from 'react'
import { useParams, useNavigate } from 'react-router-dom'
import io from 'socket.io-client'
import { Device } from 'mediasoup-client'
import { 
  Mic, 
  MicOff, 
  Video, 
  VideoOff,
  Monitor, 
  MonitorOff,
  PhoneOff,
  Settings,
  MessageSquare,
  Users,
  Volume2, 
  VolumeX,
  Loader2,
  Send,
  X
} from 'lucide-react'

/**
 * Room Component - Video Call Interface
 * 
 * T√≠nh nƒÉng:
 * - WebRTC video/audio streaming
 * - Real-time translation & captions
 * - Screen sharing
 * - Chat system
 * - Device controls
 * - Settings panel
 */
export default function Room() {
  const { roomId } = useParams()
  const navigate = useNavigate()
  
  // ============================================
  // STATE MANAGEMENT
  // ============================================
  
  // User & Connection State
  const [userId] = useState(() => {
    return localStorage.getItem('jb_username') || 
           'anonymous-' + Math.random().toString(36).substring(7)
  })
  const [username] = useState(() => {
    return localStorage.getItem('jb_username') || 'Anonymous'
  })
  const [socket, setSocket] = useState(null)
  const [connectionState, setConnectionState] = useState('connecting')
  
  // Media State
  const [isAudioEnabled, setIsAudioEnabled] = useState(true)
  const [isVideoEnabled, setIsVideoEnabled] = useState(true)
  const [isScreenSharing, setIsScreenSharing] = useState(false)
  const [localStream, setLocalStream] = useState(null)
  const [screenStream, setScreenStream] = useState(null)
  
  // Participants State
  const [participants, setParticipants] = useState([])
  const [activeSpeaker, setActiveSpeaker] = useState(null)
  
  // UI State
  const [isSettingsOpen, setIsSettingsOpen] = useState(false)
  const [isChatOpen, setIsChatOpen] = useState(false)
  const [isParticipantsOpen, setIsParticipantsOpen] = useState(false)
  const [showControls, setShowControls] = useState(true)
  
  // Translation & Caption State
  const [translationEnabled, setTranslationEnabled] = useState(false)
  const [captions, setCaptions] = useState([])
  const [sourceLanguage, setSourceLanguage] = useState('vi')
  const [targetLanguage, setTargetLanguage] = useState('en')
  const [captionMode, setCaptionMode] = useState('off') // off, source, target, bilingual
  
  // Chat State
  const [messages, setMessages] = useState([])
  const [newMessage, setNewMessage] = useState('')
  const [unreadCount, setUnreadCount] = useState(0)
  
  // Device State
  const [audioDevices, setAudioDevices] = useState([])
  const [videoDevices, setVideoDevices] = useState([])
  const [outputDevices, setOutputDevices] = useState([])
  const [selectedAudioDevice, setSelectedAudioDevice] = useState('')
  const [selectedVideoDevice, setSelectedVideoDevice] = useState('')
  const [selectedOutputDevice, setSelectedOutputDevice] = useState('')
  
  // Refs
  const localVideoRef = useRef(null)
  const controlsTimeoutRef = useRef(null)
  const chatEndRef = useRef(null)
  const captionEndRef = useRef(null)
  
  // MediaSoup State & Refs
  const [mediasoupDevice, setMediasoupDevice] = useState(null)
  const [sendTransport, setSendTransport] = useState(null)
  const [recvTransport, setRecvTransport] = useState(null)
  const [audioProducer, setAudioProducer] = useState(null)
  const [videoProducer, setVideoProducer] = useState(null)
  const [screenProducer, setScreenProducer] = useState(null)
  const consumersRef = useRef(new Map()) // userId -> { audio: Consumer, video: Consumer }
  const remoteStreamsRef = useRef(new Map()) // userId -> MediaStream

  // ============================================
  // INITIALIZATION & CLEANUP
  // ============================================

  useEffect(() => {
    if (!username) {
      navigate('/')
      return
    }

    // Initialize Socket.IO connection
    const gatewayUrl = import.meta.env.VITE_GATEWAY_URL || 'http://localhost:3001'
    console.log('üîå Connecting to gateway:', gatewayUrl)
    
    const newSocket = io(gatewayUrl, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 5,
      timeout: 10000
    })

    newSocket.on('connect', () => {
      console.log('‚úÖ Connected to signaling server')
      setConnectionState('connected')
      
      // Join room - Socket.IO signaling expects snake_case event 'join_room'
      newSocket.emit('join_room', {
        roomId,
        name: username
      })
    })

    newSocket.on('disconnect', (reason) => {
      console.log('‚ùå Disconnected from signaling server:', reason)
      setConnectionState('disconnected')
    })

    newSocket.on('connect_error', (error) => {
      console.error('Connection error:', error)
      setConnectionState('failed')
    })

    // Room events
    newSocket.on('room-joined', (data) => {
      console.log('üéâ Joined room:', data)
      setParticipants(data.participants || [])
    })

    newSocket.on('user-joined', (data) => {
      console.log('üëã User joined:', data)
      setParticipants(prev => {
        if (prev.some(p => p.userId === data.userId)) {
          return prev
        }
        return [...prev, data]
      })
      addSystemMessage(`${data.username} ƒë√£ tham gia cu·ªôc g·ªçi`)
    })

    newSocket.on('user-left', (data) => {
      console.log('üëã User left:', data)
      setParticipants(prev => prev.filter(p => p.userId !== data.userId))
      addSystemMessage(`${data.username} ƒë√£ r·ªùi cu·ªôc g·ªçi`)
    })

    // Media state events
    newSocket.on('user-audio-state', (data) => {
      console.log('üé§ User audio state:', data)
      setParticipants(prev => prev.map(p => 
        p.userId === data.userId 
          ? { ...p, audioEnabled: data.enabled }
          : p
      ))
    })

    newSocket.on('user-video-state', (data) => {
      console.log('üìπ User video state:', data)
      setParticipants(prev => prev.map(p => 
        p.userId === data.userId 
          ? { ...p, videoEnabled: data.enabled }
          : p
      ))
    })

    // Caption events
    newSocket.on('caption', (data) => {
      console.log('üí¨ Caption received:', data)
      addCaption(data)
    })

    // Chat events
    newSocket.on('chat-message', (data) => {
      console.log('üì® Chat message:', data)
      addMessage(data)
      
      if (!isChatOpen && data.userId !== userId) {
        setUnreadCount(prev => prev + 1)
      }
    })

    // Active speaker detection
    newSocket.on('active-speaker', (data) => {
      setActiveSpeaker(data.userId)
      setTimeout(() => setActiveSpeaker(null), 3000)
    })

    // ====================================================
    // MEDIASOUP SOCKET EVENTS (kebab-case naming)
    // ====================================================

    // New producer t·ª´ remote participant
    newSocket.on('new-producer', async (data) => {
      console.log('üì° New producer from remote:', data)
      const { producerId, producerSocketId, kind } = data
      
      // Skip n·∫øu l√† producer c·ªßa ch√≠nh m√¨nh
      if (producerSocketId === newSocket.id) {
        console.log('‚è≠Ô∏è  Skipping own producer')
        return
      }
      
      try {
        await consumeMedia(producerId, producerSocketId, kind)
      } catch (error) {
        console.error('Failed to consume new producer:', error)
      }
    })

    // Producer closed t·ª´ remote participant
    newSocket.on('producer-closed', (data) => {
      console.log('üö´ Producer closed from remote:', data)
      const { producerId } = data
      
      // Find v√† remove consumer
      let foundUserId = null
      consumersRef.current.forEach((userConsumers, userId) => {
        Object.entries(userConsumers).forEach(([kind, consumer]) => {
          if (consumer.id === producerId) {
            consumer.close()
            foundUserId = userId
            
            // Remove track from stream
            const remoteStream = remoteStreamsRef.current.get(userId)
            if (remoteStream) {
              remoteStream.removeTrack(consumer.track)
            }
            
            delete userConsumers[kind]
          }
        })
      })
      
      if (foundUserId) {
        const userConsumers = consumersRef.current.get(foundUserId)
        if (userConsumers && Object.keys(userConsumers).length === 0) {
          consumersRef.current.delete(foundUserId)
          remoteStreamsRef.current.delete(foundUserId)
        }
      }
    })

    setSocket(newSocket)

    // Initialize media devices THEN MediaSoup
    const initializeEverything = async () => {
      try {
        // Get local stream first
        const stream = await initializeMediaDevices()
        
        // Wait cho socket connect
        await new Promise((resolve) => {
          if (newSocket.connected) {
            resolve()
          } else {
            newSocket.once('connect', resolve)
          }
        })
        
        // Initialize MediaSoup with newSocket instance - returns transports
        const transports = await initializeMediasoup(newSocket)
        
        // Start producing local media (pass stream and transports directly)
        await startProducing(stream, transports)
        
        console.log('‚úÖ Full initialization complete')
      } catch (error) {
        console.error('‚ùå Initialization failed:', error)
        setConnectionState('failed')
      }
    }
    
    initializeEverything()

    return () => {
      console.log('üßπ Cleaning up Room component')
      
      // Close producers
      if (audioProducer) {
        audioProducer.close()
      }
      if (videoProducer) {
        videoProducer.close()
      }
      if (screenProducer) {
        screenProducer.close()
      }
      
      // Close consumers
      consumersRef.current.forEach((userConsumers) => {
        Object.values(userConsumers).forEach(consumer => {
          if (consumer) consumer.close()
        })
      })
      consumersRef.current.clear()
      remoteStreamsRef.current.clear()
      
      // Close transports
      if (sendTransport) {
        sendTransport.close()
      }
      if (recvTransport) {
        recvTransport.close()
      }
      
      // Stop local streams
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop())
      }
      if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop())
      }
      
      // Disconnect socket
      if (newSocket) {
        newSocket.emit('leave-room', { roomId, userId })
        newSocket.disconnect()
      }
    }
  }, [username, roomId, navigate, userId])

  // Auto-hide controls
  useEffect(() => {
    const handleMouseMove = () => {
      setShowControls(true)
      if (controlsTimeoutRef.current) {
        clearTimeout(controlsTimeoutRef.current)
      }
      controlsTimeoutRef.current = setTimeout(() => {
        setShowControls(false)
      }, 3000)
    }

    const handleKeyDown = () => {
      setShowControls(true)
    }

    window.addEventListener('mousemove', handleMouseMove)
    window.addEventListener('keydown', handleKeyDown)
    
    return () => {
      window.removeEventListener('mousemove', handleMouseMove)
      window.removeEventListener('keydown', handleKeyDown)
      if (controlsTimeoutRef.current) {
        clearTimeout(controlsTimeoutRef.current)
      }
    }
  }, [])

  // Auto-scroll chat
  useEffect(() => {
    if (isChatOpen) {
      chatEndRef.current?.scrollIntoView({ behavior: 'smooth' })
      setUnreadCount(0)
    }
  }, [messages, isChatOpen])

  // Auto-scroll captions
  useEffect(() => {
    captionEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [captions])

  // ============================================
  // MEDIA DEVICE INITIALIZATION
  // ============================================

  const initializeMediaDevices = async () => {
    try {
      console.log('üé• Requesting media permissions...')
      
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 1280 },
          height: { ideal: 720 },
          facingMode: 'user'
        },
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        }
      })

      console.log('‚úÖ Media permissions granted')
      setLocalStream(stream)
      
      if (localVideoRef.current) {
        localVideoRef.current.srcObject = stream
      }

      // Enumerate devices
      const devices = await navigator.mediaDevices.enumerateDevices()
      const audio = devices.filter(d => d.kind === 'audioinput')
      const video = devices.filter(d => d.kind === 'videoinput')
      const output = devices.filter(d => d.kind === 'audiooutput')
      
      setAudioDevices(audio)
      setVideoDevices(video)
      setOutputDevices(output)
      
      // Set defaults
      const audioTrack = stream.getAudioTracks()[0]
      const videoTrack = stream.getVideoTracks()[0]
      
      if (audioTrack) {
        setSelectedAudioDevice(audioTrack.getSettings().deviceId || audio[0]?.deviceId || '')
      }
      if (videoTrack) {
        setSelectedVideoDevice(videoTrack.getSettings().deviceId || video[0]?.deviceId || '')
      }
      if (output.length > 0) {
        setSelectedOutputDevice(output[0].deviceId)
      }

      console.log('‚úÖ Devices:', { audio: audio.length, video: video.length, output: output.length })
      
      // Return stream for immediate use
      return stream
    } catch (error) {
      console.error('‚ùå Failed to initialize media:', error)
      
      let errorMessage = 'Kh√¥ng th·ªÉ kh·ªüi t·∫°o camera/microphone.'
      if (error.name === 'NotAllowedError') {
        errorMessage = 'B·∫°n ƒë√£ t·ª´ ch·ªëi quy·ªÅn truy c·∫≠p. Vui l√≤ng c·∫•p quy·ªÅn trong c√†i ƒë·∫∑t tr√¨nh duy·ªát.'
      } else if (error.name === 'NotFoundError') {
        errorMessage = 'Kh√¥ng t√¨m th·∫•y camera ho·∫∑c microphone.'
      } else if (error.name === 'NotReadableError') {
        errorMessage = 'Camera/microphone ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi ·ª©ng d·ª•ng kh√°c.'
      }
      
      alert(errorMessage)
      setConnectionState('failed')
    }
  }

  // ============================================
  // MEDIASOUP INTEGRATION
  // ============================================

  /**
   * Initialize MediaSoup Device v√† load router RTP capabilities
   */
  const initializeMediasoup = async (socketInstance) => {
    try {
      console.log('üé¨ Initializing MediaSoup device...')
      
      if (!socketInstance) {
        throw new Error('Socket not connected')
      }

      // Create MediaSoup Device
      const device = new Device()
      
      // Request router RTP capabilities from Gateway
      const routerRtpCapabilities = await new Promise((resolve, reject) => {
        socketInstance.emit('getRouterRtpCapabilities', { roomId }, (response) => {
          if (response.error) {
            reject(new Error(response.error))
          } else {
            resolve(response.rtpCapabilities)
          }
        })
        
        // Timeout sau 10s
        setTimeout(() => reject(new Error('Timeout getting router capabilities')), 10000)
      })

      console.log('‚úÖ Got router RTP capabilities')
      
      // Load device v·ªõi router capabilities
      await device.load({ routerRtpCapabilities })
      console.log('‚úÖ MediaSoup device loaded')
      
      // Check device capabilities
      const canProduceVideo = device.canProduce('video')
      const canProduceAudio = device.canProduce('audio')
      console.log(`üìπ Can produce: video=${canProduceVideo}, audio=${canProduceAudio}`)
      
      if (!canProduceVideo || !canProduceAudio) {
        throw new Error('Device cannot produce media')
      }
      
      setMediasoupDevice(device)
      
      // Create transports
      const transports = await createTransports(device, socketInstance)
      
      return transports
    } catch (error) {
      console.error('‚ùå Failed to initialize MediaSoup:', error)
      throw error
    }
  }

  /**
   * Create Send v√† Receive Transports
   */
  const createTransports = async (device, socketInstance) => {
    try {
      console.log('üöö Creating transports...')
      
      // Create Send Transport
      const sendTransportParams = await new Promise((resolve, reject) => {
        socketInstance.emit('createWebRtcTransport', {
          roomId,
          userId,
          forceTcp: true,  // üîÑ Force TCP (bypass UDP issues)
          producing: true,
          consuming: false
        }, (response) => {
          console.log('üì¶ Send transport response received:', JSON.stringify(response, null, 2))
          if (response.error) {
            reject(new Error(response.error))
          } else {
            console.log('üîç ICE Candidates from server:', JSON.stringify(response.iceCandidates, null, 2))
            console.log('üîç ICE Parameters from server:', JSON.stringify(response.iceParameters, null, 2))
            resolve(response)
          }
        })
        setTimeout(() => reject(new Error('Timeout creating send transport')), 10000)
      })

      console.log('‚úÖ Got send transport params')
      console.log('üîç Full sendTransportParams:', JSON.stringify(sendTransportParams, null, 2))
      
      // üîß Filter ICE candidates - ONLY use TCP to bypass UDP blocks
      const tcpCandidates = sendTransportParams.iceCandidates.filter(c => c.protocol === 'tcp')
      console.log('üîß Filtered to TCP only:', JSON.stringify(tcpCandidates, null, 2))
      
      const sendTrans = device.createSendTransport({
        id: sendTransportParams.id,
        iceParameters: sendTransportParams.iceParameters,
        iceCandidates: tcpCandidates,  // Use ONLY TCP candidates
        dtlsParameters: sendTransportParams.dtlsParameters,
        sctpParameters: sendTransportParams.sctpParameters
      })

      // Handle send transport events
      sendTrans.on('connect', async ({ dtlsParameters }, callback, errback) => {
        try {
          console.log('üîó Send transport connecting...', {
            transportId: sendTrans.id,
            iceParameters: sendTransportParams.iceParameters,
            iceCandidates: sendTransportParams.iceCandidates
          })
          await new Promise((resolve, reject) => {
            socketInstance.emit('connectWebRtcTransport', {
              roomId,
              transportId: sendTrans.id,
              dtlsParameters
            }, (response) => {
              if (response.error) {
                reject(new Error(response.error))
              } else {
                resolve()
              }
            })
            setTimeout(() => reject(new Error('Timeout connecting transport')), 10000)
          })
          console.log('‚úÖ Send transport connected (DTLS handshake complete)')
          callback()
        } catch (error) {
          console.error('‚ùå Send transport connect failed:', error)
          errback(error)
        }
      })

      sendTrans.on('produce', async ({ kind, rtpParameters, appData }, callback, errback) => {
        try {
          console.log(`üì§ Producing ${kind}...`)
          const { id } = await new Promise((resolve, reject) => {
            socketInstance.emit('produce', {
              roomId,
              transportId: sendTrans.id,
              kind,
              rtpParameters,
              appData
            }, (response) => {
              if (response.error) {
                reject(new Error(response.error))
              } else {
                resolve(response)
              }
            })
            setTimeout(() => reject(new Error('Timeout producing')), 10000)
          })
          console.log(`‚úÖ Producer created: ${kind} - ${id}`)
          callback({ id })
        } catch (error) {
          console.error(`‚ùå Produce ${kind} failed:`, error)
          errback(error)
        }
      })

      sendTrans.on('connectionstatechange', (state) => {
        console.log(`üö¶ Send transport state: ${state}`)
        if (state === 'failed' || state === 'closed') {
          console.error('‚ùå Send transport failed/closed')
          // Log detailed ICE state
          console.log('üîç Transport details:', {
            id: sendTrans.id,
            iceState: sendTrans.iceState,
            iceGatheringState: sendTrans.iceGatheringState,
            dtlsState: sendTrans.dtlsState
          })
          setConnectionState('failed')
        }
      })
      
      // Add ICE state monitoring
      sendTrans.on('icestatechange', (iceState) => {
        console.log(`üßä Send transport ICE state: ${iceState}`)
      })
      
      // Add ICE gathering monitoring
      sendTrans.on('icegatheringstatechange', (state) => {
        console.log(`üåê Send transport ICE gathering: ${state}`)
      })
      
      // Add DTLS state monitoring
      sendTrans.on('dtlsstatechange', (dtlsState) => {
        console.log(`üîê Send transport DTLS state: ${dtlsState}`)
      })

      setSendTransport(sendTrans)

      // Create Receive Transport
      const recvTransportParams = await new Promise((resolve, reject) => {
        socketInstance.emit('createWebRtcTransport', {
          roomId,
          userId,
          forceTcp: true,  // üîÑ Force TCP (bypass UDP issues)
          producing: false,
          consuming: true
        }, (response) => {
          if (response.error) {
            reject(new Error(response.error))
          } else {
            resolve(response)
          }
        })
        setTimeout(() => reject(new Error('Timeout creating recv transport')), 10000)
      })

      console.log('‚úÖ Got recv transport params')
      
      // üîß Filter ICE candidates - ONLY use TCP to bypass UDP blocks
      const tcpCandidatesRecv = recvTransportParams.iceCandidates.filter(c => c.protocol === 'tcp')
      console.log('üîß Recv filtered to TCP only:', JSON.stringify(tcpCandidatesRecv, null, 2))
      
      const recvTrans = device.createRecvTransport({
        id: recvTransportParams.id,
        iceParameters: recvTransportParams.iceParameters,
        iceCandidates: tcpCandidatesRecv,  // Use ONLY TCP candidates
        dtlsParameters: recvTransportParams.dtlsParameters,
        sctpParameters: recvTransportParams.sctpParameters
      })

      recvTrans.on('connect', async ({ dtlsParameters }, callback, errback) => {
        try {
          console.log('üîó Recv transport connecting...')
          await new Promise((resolve, reject) => {
            socketInstance.emit('connectWebRtcTransport', {
              roomId,
              transportId: recvTrans.id,
              dtlsParameters
            }, (response) => {
              if (response.error) {
                reject(new Error(response.error))
              } else {
                resolve()
              }
            })
            setTimeout(() => reject(new Error('Timeout connecting transport')), 10000)
          })
          console.log('‚úÖ Recv transport connected')
          callback()
        } catch (error) {
          console.error('‚ùå Recv transport connect failed:', error)
          errback(error)
        }
      })

      recvTrans.on('connectionstatechange', (state) => {
        console.log(`üö¶ Recv transport state: ${state}`)
        if (state === 'failed' || state === 'closed') {
          console.error('‚ùå Recv transport failed/closed')
        }
      })

      setRecvTransport(recvTrans)

      console.log('‚úÖ Transports created successfully')
      
      // Return transports for immediate use
      return { sendTransport: sendTrans, recvTransport: recvTrans }
    } catch (error) {
      console.error('‚ùå Failed to create transports:', error)
      throw error
    }
  }

  /**
   * Start producing local media (audio + video)
   */
  const startProducing = async (stream = localStream, transports = null) => {
    try {
      // Use provided transports or fall back to state
      const sendTrans = transports?.sendTransport || sendTransport
      
      if (!sendTrans || !stream) {
        throw new Error('Send transport or local stream not ready')
      }

      console.log('üé¨ Starting to produce media...')

      // Produce audio
      const audioTrack = stream.getAudioTracks()[0]
      if (audioTrack) {
        const producer = await sendTrans.produce({
          track: audioTrack,
          codecOptions: {
            opusStereo: true,
            opusDtx: true
          },
          appData: { type: 'audio', userId }
        })
        console.log('‚úÖ Audio producer created:', producer.id)
        setAudioProducer(producer)
        
        producer.on('transportclose', () => {
          console.log('üö´ Audio producer transport closed')
          setAudioProducer(null)
        })
        
        producer.on('trackended', () => {
          console.log('üé§ Audio track ended')
        })
      }

      // Produce video
      const videoTrack = stream.getVideoTracks()[0]
      if (videoTrack) {
        const producer = await sendTrans.produce({
          track: videoTrack,
          encodings: [
            { maxBitrate: 100000, scaleResolutionDownBy: 4 },
            { maxBitrate: 300000, scaleResolutionDownBy: 2 },
            { maxBitrate: 900000, scaleResolutionDownBy: 1 }
          ],
          codecOptions: {
            videoGoogleStartBitrate: 1000
          },
          appData: { type: 'video', userId }
        })
        console.log('‚úÖ Video producer created:', producer.id)
        setVideoProducer(producer)
        
        producer.on('transportclose', () => {
          console.log('üö´ Video producer transport closed')
          setVideoProducer(null)
        })
        
        producer.on('trackended', () => {
          console.log('üìπ Video track ended')
        })
      }

      console.log('‚úÖ Media production started')
    } catch (error) {
      console.error('‚ùå Failed to start producing:', error)
      throw error
    }
  }

  /**
   * Consume remote participant's media
   */
  const consumeMedia = async (producerId, producerUserId, kind) => {
    try {
      if (!recvTransport || !mediasoupDevice) {
        throw new Error('Recv transport or device not ready')
      }

      console.log(`üì• Consuming ${kind} from ${producerUserId}...`)

      const { id, rtpParameters } = await new Promise((resolve, reject) => {
        socket.emit('consume', {
          transportId: recvTransport.id,
          producerId,
          rtpCapabilities: mediasoupDevice.rtpCapabilities
        }, (response) => {
          if (response.error) {
            reject(new Error(response.error))
          } else {
            resolve(response)
          }
        })
        setTimeout(() => reject(new Error('Timeout consuming')), 10000)
      })

      const consumer = await recvTransport.consume({
        id,
        producerId,
        kind,
        rtpParameters
      })

      console.log(`‚úÖ Consumer created: ${kind} from ${producerUserId}`)

      // Store consumer
      if (!consumersRef.current.has(producerUserId)) {
        consumersRef.current.set(producerUserId, {})
      }
      consumersRef.current.get(producerUserId)[kind] = consumer

      // Resume consumer on server (backend expects 'resume_consumer')
      socket.emit('resume_consumer', {
        consumerId: consumer.id
      }, (response) => {
        if (response && response.error) {
          console.error('Failed to resume consumer:', response.error)
        } else {
          console.log('‚úÖ Consumer resumed:', consumer.id)
        }
      })

      // Get or create remote stream
      let remoteStream = remoteStreamsRef.current.get(producerUserId)
      if (!remoteStream) {
        remoteStream = new MediaStream()
        remoteStreamsRef.current.set(producerUserId, remoteStream)
      }

      // Add track to stream
      remoteStream.addTrack(consumer.track)

      // Update participants v·ªõi remote stream
      setParticipants(prev => prev.map(p =>
        p.userId === producerUserId
          ? { ...p, stream: remoteStream }
          : p
      ))

      consumer.on('transportclose', () => {
        console.log(`üö´ Consumer transport closed: ${kind} from ${producerUserId}`)
      })

      consumer.on('producerclose', () => {
        console.log(`üö´ Producer closed: ${kind} from ${producerUserId}`)
        // Remove track from stream
        remoteStream.removeTrack(consumer.track)
        
        // Remove consumer
        const userConsumers = consumersRef.current.get(producerUserId)
        if (userConsumers) {
          delete userConsumers[kind]
          if (Object.keys(userConsumers).length === 0) {
            consumersRef.current.delete(producerUserId)
            remoteStreamsRef.current.delete(producerUserId)
          }
        }
      })

      return consumer
    } catch (error) {
      console.error(`‚ùå Failed to consume ${kind}:`, error)
      throw error
    }
  }

  // ============================================
  // MEDIA CONTROLS
  // ============================================

  const toggleAudio = () => {
    if (localStream) {
      const audioTrack = localStream.getAudioTracks()[0]
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled
        setIsAudioEnabled(audioTrack.enabled)
        
        if (socket) {
          socket.emit('audio-state-change', {
            roomId,
            userId,
            enabled: audioTrack.enabled
          })
        }
      }
    }
  }

  const toggleVideo = () => {
    if (localStream) {
      const videoTrack = localStream.getVideoTracks()[0]
      if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled
        setIsVideoEnabled(videoTrack.enabled)
        
        if (socket) {
          socket.emit('video-state-change', {
            roomId,
            userId,
            enabled: videoTrack.enabled
          })
        }
      }
    }
  }

  const toggleScreenShare = async () => {
    if (isScreenSharing) {
      if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop())
        setScreenStream(null)
        setIsScreenSharing(false)
        
        if (localVideoRef.current && localStream) {
          localVideoRef.current.srcObject = localStream
        }
        
        if (socket) {
          socket.emit('screen-share-stopped', { roomId, userId })
        }
      }
    } else {
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: { cursor: 'always' },
          audio: false
        })

        setScreenStream(stream)
        setIsScreenSharing(true)
        
        if (localVideoRef.current) {
          localVideoRef.current.srcObject = stream
        }
        
        if (socket) {
          socket.emit('screen-share-started', { roomId, userId })
        }

        stream.getVideoTracks()[0].onended = () => {
          setScreenStream(null)
          setIsScreenSharing(false)
          
          if (localVideoRef.current && localStream) {
            localVideoRef.current.srcObject = localStream
          }
          
          if (socket) {
            socket.emit('screen-share-stopped', { roomId, userId })
          }
        }
      } catch (error) {
        if (error.name !== 'NotAllowedError') {
          alert('Kh√¥ng th·ªÉ chia s·∫ª m√†n h√¨nh.')
        }
      }
    }
  }

  const leaveCall = () => {
    if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën r·ªùi kh·ªèi cu·ªôc g·ªçi?')) {
      if (socket) {
        socket.emit('leave-room', { roomId, userId })
      }
      navigate('/')
    }
  }

  // ============================================
  // TRANSLATION & CAPTIONS
  // ============================================

  const toggleTranslation = () => {
    const newState = !translationEnabled
    setTranslationEnabled(newState)
    
    if (socket) {
      socket.emit('translation-state-change', {
        roomId,
        userId,
        enabled: newState,
        sourceLanguage,
        targetLanguage
      })
    }
  }

  const addCaption = (data) => {
    const caption = {
      id: Date.now() + Math.random(),
      userId: data.userId,
      username: data.username,
      userColor: data.userColor || getUserColor(data.userId),
      textSource: data.textSource || data.text,
      textTarget: data.textTarget || '',
      timestamp: data.timestamp || Date.now()
    }
    
    setCaptions(prev => [...prev, caption].slice(-50))
    setTimeout(() => {
      setCaptions(prev => prev.filter(c => c.id !== caption.id))
    }, 5000)
  }

  const getUserColor = (userId) => {
    const colors = ['#14b8a6', '#8b5cf6', '#f59e0b', '#3b82f6', '#ec4899', '#10b981', '#f43f5e', '#6366f1']
    let hash = 0
    for (let i = 0; i < userId.length; i++) {
      hash = userId.charCodeAt(i) + ((hash << 5) - hash)
    }
    return colors[Math.abs(hash) % colors.length]
  }

  // ============================================
  // CHAT FUNCTIONS
  // ============================================

  const addMessage = (data) => {
    const message = {
      id: Date.now() + Math.random(),
      userId: data.userId,
      username: data.username,
      message: data.message,
      timestamp: data.timestamp || Date.now(),
      type: data.type || 'user'
    }
    setMessages(prev => [...prev, message])
  }

  const addSystemMessage = (text) => {
    addMessage({
      userId: 'system',
      username: 'System',
      message: text,
      type: 'system'
    })
  }

  const sendMessage = (e) => {
    e.preventDefault()
    if (!newMessage.trim()) return
    
    const message = {
      roomId,
      userId,
      username,
      message: newMessage.trim(),
      timestamp: Date.now()
    }
    
    if (socket) {
      socket.emit('chat-message', message)
    }
    addMessage({ ...message, type: 'user' })
    setNewMessage('')
  }

  // ============================================
  // DEVICE CHANGE HANDLERS
  // ============================================

  const changeAudioDevice = async (deviceId) => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: { 
          deviceId: { exact: deviceId },
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        },
        video: false
      })
      
      if (localStream) {
        const oldTrack = localStream.getAudioTracks()[0]
        if (oldTrack) {
          localStream.removeTrack(oldTrack)
          oldTrack.stop()
        }
        
        const newTrack = stream.getAudioTracks()[0]
        newTrack.enabled = isAudioEnabled
        localStream.addTrack(newTrack)
      }
      setSelectedAudioDevice(deviceId)
    } catch (error) {
      alert('Kh√¥ng th·ªÉ chuy·ªÉn microphone.')
    }
  }

  const changeVideoDevice = async (deviceId) => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { 
          deviceId: { exact: deviceId },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: false
      })
      
      if (localStream) {
        const oldTrack = localStream.getVideoTracks()[0]
        if (oldTrack) {
          localStream.removeTrack(oldTrack)
          oldTrack.stop()
        }
        
        const newTrack = stream.getVideoTracks()[0]
        newTrack.enabled = isVideoEnabled
        localStream.addTrack(newTrack)
        
        if (localVideoRef.current && !isScreenSharing) {
          localVideoRef.current.srcObject = localStream
        }
      }
      setSelectedVideoDevice(deviceId)
    } catch (error) {
      alert('Kh√¥ng th·ªÉ chuy·ªÉn camera.')
    }
  }

  // ============================================
  // RENDER
  // ============================================

  if (!username) {
    return null
  }

  return (
    <div className="room-container">
      {/* Connection Status */}
      {connectionState !== 'connected' && (
        <div className={`connection-status connection-status-${connectionState}`}>
          {connectionState === 'connecting' && (
            <>
              <Loader2 className="icon-spin" size={16} />
              <span>ƒêang k·∫øt n·ªëi...</span>
            </>
          )}
          {connectionState === 'disconnected' && (
            <>
              <Loader2 className="icon-spin" size={16} />
              <span>‚ö†Ô∏è M·∫•t k·∫øt n·ªëi - ƒêang th·ª≠ l·∫°i...</span>
            </>
          )}
          {connectionState === 'failed' && (
            <span>‚ùå K·∫øt n·ªëi th·∫•t b·∫°i - Vui l√≤ng t·∫£i l·∫°i trang</span>
          )}
        </div>
      )}

      {/* Video Grid */}
      <div className="video-grid">
        <div className={`video-tile video-tile-local ${activeSpeaker === userId ? 'active-speaker' : ''}`}>
          <video
            ref={localVideoRef}
            autoPlay
            playsInline
            muted
            className="video-element"
          />
          {!isVideoEnabled && !isScreenSharing && (
            <div className="video-placeholder">
              <Users size={48} />
              <p>{username}</p>
            </div>
          )}
          <div className="video-overlay">
            <span className="participant-name">{username} (B·∫°n)</span>
            <div className="video-status-indicators">
              {!isAudioEnabled && <MicOff size={16} className="status-indicator" />}
              {!isVideoEnabled && <VideoOff size={16} className="status-indicator" />}
              {isScreenSharing && <Monitor size={16} className="status-indicator status-active" />}
            </div>
          </div>
        </div>

        {participants.map((participant) => (
          <div 
            key={participant.userId}
            className={`video-tile ${activeSpeaker === participant.userId ? 'active-speaker' : ''}`}
          >
            <div className="video-placeholder">
              <Users size={48} />
              <p>{participant.username}</p>
            </div>
            <div className="video-overlay">
              <span className="participant-name">{participant.username}</span>
              <div className="video-status-indicators">
                {!participant.audioEnabled && <MicOff size={16} className="status-indicator" />}
                {!participant.videoEnabled && <VideoOff size={16} className="status-indicator" />}
              </div>
            </div>
          </div>
        ))}

        {participants.length === 0 && (
          <div className="video-empty-state">
            <Users size={64} />
            <p>ƒêang ch·ªù ng∆∞·ªùi kh√°c tham gia...</p>
            <p className="room-code">M√£ ph√≤ng: <strong>{roomId}</strong></p>
            <p className="room-hint">Chia s·∫ª m√£ n√†y ƒë·ªÉ m·ªùi ng∆∞·ªùi kh√°c</p>
          </div>
        )}
      </div>

      {/* Captions */}
      {captionMode !== 'off' && captions.length > 0 && (
        <div className="captions-container">
          {captions.slice(-3).map((caption) => (
            <div key={caption.id} className="caption-item fade-in-up">
              <span className="caption-username" style={{ color: caption.userColor }}>
                [{caption.username}]
              </span>
              {captionMode === 'source' && (
                <span className="caption-text">{caption.textSource}</span>
              )}
              {captionMode === 'target' && (
                <span className="caption-text">{caption.textTarget || caption.textSource}</span>
              )}
              {captionMode === 'bilingual' && (
                <div className="caption-bilingual">
                  <span className="caption-text">{caption.textSource}</span>
                  {caption.textTarget && (
                    <>
                      <span className="caption-arrow">‚Üí</span>
                      <span className="caption-text caption-translated">{caption.textTarget}</span>
                    </>
                  )}
                </div>
              )}
            </div>
          ))}
          <div ref={captionEndRef} />
        </div>
      )}

      {/* Control Bar */}
      <div className={`control-bar ${showControls ? 'visible' : 'hidden'}`}>
        <div className="control-group">
          <div className="room-info-badge">
            Room: <strong>{roomId}</strong>
          </div>
        </div>

        <div className="control-group control-group-center">
          <button
            className={`control-btn ${!isAudioEnabled ? 'control-btn-danger' : ''}`}
            onClick={toggleAudio}
            title={isAudioEnabled ? 'T·∫Øt mic' : 'B·∫≠t mic'}
          >
            {isAudioEnabled ? <Mic size={20} /> : <MicOff size={20} />}
          </button>

          <button
            className={`control-btn ${!isVideoEnabled ? 'control-btn-danger' : ''}`}
            onClick={toggleVideo}
            title={isVideoEnabled ? 'T·∫Øt camera' : 'B·∫≠t camera'}
          >
            {isVideoEnabled ? <Video size={20} /> : <VideoOff size={20} />}
          </button>

          <button
            className={`control-btn ${isScreenSharing ? 'control-btn-active' : ''}`}
            onClick={toggleScreenShare}
            title={isScreenSharing ? 'D·ª´ng chia s·∫ª' : 'Chia s·∫ª m√†n h√¨nh'}
          >
            {isScreenSharing ? <MonitorOff size={20} /> : <Monitor size={20} />}
          </button>

          <button
            className={`control-btn ${translationEnabled ? 'control-btn-active' : ''}`}
            onClick={toggleTranslation}
            title={translationEnabled ? 'T·∫Øt d·ªãch' : 'B·∫≠t d·ªãch'}
          >
            {translationEnabled ? <Volume2 size={20} /> : <VolumeX size={20} />}
          </button>

          <button
            className="control-btn control-btn-danger control-btn-large"
            onClick={leaveCall}
            title="R·ªùi cu·ªôc g·ªçi"
          >
            <PhoneOff size={20} />
          </button>
        </div>

        <div className="control-group">
          <button
            className={`control-btn ${isChatOpen ? 'control-btn-active' : ''}`}
            onClick={() => setIsChatOpen(!isChatOpen)}
            title="Chat"
          >
            <MessageSquare size={20} />
            {unreadCount > 0 && (
              <span className="control-badge control-badge-danger">{unreadCount}</span>
            )}
          </button>

          <button
            className={`control-btn ${isParticipantsOpen ? 'control-btn-active' : ''}`}
            onClick={() => setIsParticipantsOpen(!isParticipantsOpen)}
            title="Ng∆∞·ªùi tham gia"
          >
            <Users size={20} />
            <span className="control-badge">{participants.length + 1}</span>
          </button>

          <button
            className={`control-btn ${isSettingsOpen ? 'control-btn-active' : ''}`}
            onClick={() => setIsSettingsOpen(!isSettingsOpen)}
            title="C√†i ƒë·∫∑t"
          >
            <Settings size={20} />
          </button>
        </div>
      </div>

      {/* Chat Panel */}
      {isChatOpen && (
        <div className="side-panel chat-panel fade-in-right">
          <div className="panel-header">
            <h3>
              <MessageSquare size={20} />
              <span>Chat</span>
            </h3>
            <button className="panel-close" onClick={() => setIsChatOpen(false)}>
              <X size={20} />
            </button>
          </div>
          
          <div className="chat-messages">
            {messages.length === 0 && (
              <div className="chat-empty-state">
                <MessageSquare size={48} />
                <p>Ch∆∞a c√≥ tin nh·∫Øn</p>
                <p className="chat-hint">G·ª≠i tin nh·∫Øn ƒë·∫ßu ti√™n!</p>
              </div>
            )}
            
            {messages.map((msg) => (
              <div 
                key={msg.id}
                className={`chat-message ${msg.type === 'system' ? 'chat-message-system' : ''} ${msg.userId === userId ? 'chat-message-self' : ''}`}
              >
                {msg.type === 'user' && (
                  <>
                    <div className="chat-message-header">
                      <strong>{msg.username}</strong>
                      <span className="chat-time">
                        {new Date(msg.timestamp).toLocaleTimeString('vi-VN', {
                          hour: '2-digit',
                          minute: '2-digit'
                        })}
                      </span>
                    </div>
                    <p className="chat-message-text">{msg.message}</p>
                  </>
                )}
                {msg.type === 'system' && (
                  <span className="chat-system-text">{msg.message}</span>
                )}
              </div>
            ))}
            <div ref={chatEndRef} />
          </div>

          <form className="chat-input-form" onSubmit={sendMessage}>
            <input
              type="text"
              value={newMessage}
              onChange={(e) => setNewMessage(e.target.value)}
              placeholder="Nh·∫≠p tin nh·∫Øn..."
              className="chat-input"
              maxLength={500}
            />
            <button type="submit" className="chat-send-btn" disabled={!newMessage.trim()}>
              <Send size={20} />
            </button>
          </form>
        </div>
      )}

      {/* Participants Panel */}
      {isParticipantsOpen && (
        <div className="side-panel participants-panel fade-in-right">
          <div className="panel-header">
            <h3>
              <Users size={20} />
              <span>Ng∆∞·ªùi tham gia ({participants.length + 1})</span>
            </h3>
            <button className="panel-close" onClick={() => setIsParticipantsOpen(false)}>
              <X size={20} />
            </button>
          </div>
          
          <div className="participants-list">
            <div className="participant-item participant-self">
              <div className="participant-avatar">
                <Users size={20} />
              </div>
              <div className="participant-info">
                <span className="participant-name-text">{username}</span>
                <span className="participant-badge">B·∫°n</span>
              </div>
              <div className="participant-indicators">
                {!isAudioEnabled && (
                  <span className="indicator-badge indicator-muted">
                    <MicOff size={14} />
                  </span>
                )}
                {!isVideoEnabled && (
                  <span className="indicator-badge indicator-no-video">
                    <VideoOff size={14} />
                  </span>
                )}
                {isScreenSharing && (
                  <span className="indicator-badge indicator-screen">
                    <Monitor size={14} />
                  </span>
                )}
              </div>
            </div>

            {participants.map((participant) => (
              <div key={participant.userId} className="participant-item">
                <div className="participant-avatar">
                  <Users size={20} />
                </div>
                <div className="participant-info">
                  <span className="participant-name-text">{participant.username}</span>
                  {activeSpeaker === participant.userId && (
                    <span className="participant-badge participant-speaking">ƒêang n√≥i</span>
                  )}
                </div>
                <div className="participant-indicators">
                  {!participant.audioEnabled && (
                    <span className="indicator-badge indicator-muted">
                      <MicOff size={14} />
                    </span>
                  )}
                  {!participant.videoEnabled && (
                    <span className="indicator-badge indicator-no-video">
                      <VideoOff size={14} />
                    </span>
                  )}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Settings Panel */}
      {isSettingsOpen && (
        <div className="side-panel settings-panel fade-in-right">
          <div className="panel-header">
            <h3>
              <Settings size={20} />
              <span>C√†i ƒë·∫∑t</span>
            </h3>
            <button className="panel-close" onClick={() => setIsSettingsOpen(false)}>
              <X size={20} />
            </button>
          </div>
          
          <div className="settings-content">
            {/* Device Settings */}
            <div className="settings-section">
              <h4>
                <Mic size={18} />
                <span>Thi·∫øt b·ªã</span>
              </h4>
              
              <div className="setting-item">
                <label>Microphone</label>
                <select
                  value={selectedAudioDevice}
                  onChange={(e) => changeAudioDevice(e.target.value)}
                  className="setting-select"
                >
                  {audioDevices.map((device) => (
                    <option key={device.deviceId} value={device.deviceId}>
                      {device.label || `Microphone ${device.deviceId.slice(0, 5)}`}
                    </option>
                  ))}
                </select>
              </div>

              <div className="setting-item">
                <label>Camera</label>
                <select
                  value={selectedVideoDevice}
                  onChange={(e) => changeVideoDevice(e.target.value)}
                  className="setting-select"
                >
                  {videoDevices.map((device) => (
                    <option key={device.deviceId} value={device.deviceId}>
                      {device.label || `Camera ${device.deviceId.slice(0, 5)}`}
                    </option>
                  ))}
                </select>
              </div>

              {outputDevices.length > 0 && (
                <div className="setting-item">
                  <label>Loa</label>
                  <select
                    value={selectedOutputDevice}
                    onChange={(e) => setSelectedOutputDevice(e.target.value)}
                    className="setting-select"
                  >
                    {outputDevices.map((device) => (
                      <option key={device.deviceId} value={device.deviceId}>
                        {device.label || `Speaker ${device.deviceId.slice(0, 5)}`}
                      </option>
                    ))}
                  </select>
                </div>
              )}
            </div>

            {/* Translation Settings */}
            <div className="settings-section">
              <h4>
                <Volume2 size={18} />
                <span>D·ªãch thu·∫≠t</span>
              </h4>
              
              <div className="setting-item">
                <label>Ng√¥n ng·ªØ g·ªëc (b·∫°n n√≥i)</label>
                <select
                  value={sourceLanguage}
                  onChange={(e) => setSourceLanguage(e.target.value)}
                  className="setting-select"
                >
                  <option value="vi">üáªüá≥ Ti·∫øng Vi·ªát</option>
                  <option value="en">üá∫üá∏ English</option>
                  <option value="ja">üáØüáµ Êó•Êú¨Ë™û</option>
                  <option value="ko">üá∞üá∑ ÌïúÍµ≠Ïñ¥</option>
                  <option value="zh">üá®üá≥ ‰∏≠Êñá</option>
                  <option value="fr">üá´üá∑ Fran√ßais</option>
                  <option value="de">üá©üá™ Deutsch</option>
                  <option value="es">üá™üá∏ Espa√±ol</option>
                </select>
              </div>

              <div className="setting-item">
                <label>Ng√¥n ng·ªØ d·ªãch (b·∫°n nghe)</label>
                <select
                  value={targetLanguage}
                  onChange={(e) => setTargetLanguage(e.target.value)}
                  className="setting-select"
                >
                  <option value="en">üá∫üá∏ English</option>
                  <option value="vi">üáªüá≥ Ti·∫øng Vi·ªát</option>
                  <option value="ja">üáØüáµ Êó•Êú¨Ë™û</option>
                  <option value="ko">üá∞üá∑ ÌïúÍµ≠Ïñ¥</option>
                  <option value="zh">üá®üá≥ ‰∏≠Êñá</option>
                  <option value="fr">üá´üá∑ Fran√ßais</option>
                  <option value="de">üá©üá™ Deutsch</option>
                  <option value="es">üá™üá∏ Espa√±ol</option>
                </select>
              </div>
            </div>

            {/* Caption Settings */}
            <div className="settings-section">
              <h4>
                <MessageSquare size={18} />
                <span>Ph·ª• ƒë·ªÅ</span>
              </h4>
              
              <div className="setting-item">
                <label>Ch·∫ø ƒë·ªô hi·ªÉn th·ªã</label>
                <select
                  value={captionMode}
                  onChange={(e) => setCaptionMode(e.target.value)}
                  className="setting-select"
                >
                  <option value="off">‚ùå T·∫Øt ph·ª• ƒë·ªÅ</option>
                  <option value="source">üìù Ch·ªâ ng√¥n ng·ªØ g·ªëc</option>
                  <option value="target">üåê Ch·ªâ ng√¥n ng·ªØ d·ªãch</option>
                  <option value="bilingual">üîÑ Song ng·ªØ (g·ªëc + d·ªãch)</option>
                </select>
              </div>

              <div className="setting-hint">
                <p>üí° Ph·ª• ƒë·ªÅ t·ª± ƒë·ªông bi·∫øn m·∫•t sau 5 gi√¢y</p>
              </div>
            </div>

            {/* Info */}
            <div className="settings-section settings-info">
              <h4>‚ÑπÔ∏è Th√¥ng tin</h4>
              <div className="info-grid">
                <div className="info-item">
                  <span className="info-label">M√£ ph√≤ng:</span>
                  <span className="info-value">{roomId}</span>
                </div>
                <div className="info-item">
                  <span className="info-label">Ng∆∞·ªùi tham gia:</span>
                  <span className="info-value">{participants.length + 1}</span>
                </div>
                <div className="info-item">
                  <span className="info-label">K·∫øt n·ªëi:</span>
                  <span className={`info-value status-${connectionState}`}>
                    {connectionState === 'connected' && 'üü¢ ƒê√£ k·∫øt n·ªëi'}
                    {connectionState === 'connecting' && 'üü° ƒêang k·∫øt n·ªëi'}
                    {connectionState === 'disconnected' && 'üî¥ M·∫•t k·∫øt n·ªëi'}
                    {connectionState === 'failed' && '‚ùå Th·∫•t b·∫°i'}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
