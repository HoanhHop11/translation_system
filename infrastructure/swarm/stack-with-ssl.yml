# =============================================================================
# JB CALLING - Docker Stack với Traefik SSL
# =============================================================================
# Version: 3.0
# Description: Stack với Traefik reverse proxy và Let's Encrypt SSL tự động
# Usage: docker stack deploy -c stack-with-ssl.yml translation
# =============================================================================

version: '3.8'

# =============================================================================
# NETWORKS
# =============================================================================
networks:
  frontend:
    driver: overlay
    attachable: true
  backend:
    driver: overlay
    internal: true
  monitoring:
    driver: overlay

# =============================================================================
# VOLUMES
# =============================================================================
volumes:
  redis_data:            # Redis for rooms, cache, sessions
  traefik_certificates:  # Let's Encrypt SSL certificates
  models_cache:          # Cache for AI models (HuggingFace, faster-whisper)
  prometheus_data:       # Prometheus metrics storage
  grafana_data:          # Grafana dashboards
  loki_data:             # Loki logs storage

# =============================================================================
# SERVICES
# =============================================================================
services:

  # ===========================================================================
  # REVERSE PROXY - Traefik với Let's Encrypt
  # ===========================================================================
  traefik:
    image: traefik:v3.0
    command:
      # API và Dashboard
      - "--api.dashboard=true"
      - "--api.insecure=false"
      
      # Entrypoints
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--entrypoints.web.http.redirections.entryPoint.to=websecure"
      - "--entrypoints.web.http.redirections.entryPoint.scheme=https"
      - "--entrypoints.websecure.http.tls.certResolver=letsencrypt"
      
      # WebSocket entrypoint
      - "--entrypoints.websocket.address=:8001"
      
      # Docker Swarm provider (v3 syntax)
      - "--providers.swarm=true"
      - "--providers.swarm.endpoint=unix:///var/run/docker.sock"
      - "--providers.swarm.exposedbydefault=false"
      - "--providers.swarm.network=translation_frontend"
      - "--providers.swarm.watch=true"
      
      # API & Ping
      - "--ping=true"
      
      # Let's Encrypt
      - "--certificatesresolvers.letsencrypt.acme.email=${LETSENCRYPT_EMAIL}"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
      - "--certificatesresolvers.letsencrypt.acme.tlschallenge=true"
      
      # Logging
      - "--log.level=INFO"
      - "--accesslog=true"
      
    ports:
      - target: 80
        published: 80
        mode: host
      - target: 443
        published: 443
        mode: host
      - target: 8001
        published: 8001
        mode: host
        
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - traefik_certificates:/letsencrypt
      
    networks:
      - frontend
      
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
          - node.role == manager
      labels:
        # Enable Traefik
        - "traefik.enable=true"
        
        # Dashboard
        - "traefik.http.routers.traefik.rule=Host(`traefik.${DOMAIN_NAME}`)"
        - "traefik.http.routers.traefik.entrypoints=websecure"
        - "traefik.http.routers.traefik.tls.certresolver=letsencrypt"
        - "traefik.http.routers.traefik.service=api@internal"
        - "traefik.http.routers.traefik.middlewares=auth"
        
        # Basic auth (admin:admin - PHẢI ĐỔI trong production)
        - "traefik.http.middlewares.auth.basicauth.users=admin:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/"
        
        # Port
        - "traefik.http.services.traefik.loadbalancer.server.port=8080"
        
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  # ===========================================================================
  # NOTE: PostgreSQL REMOVED - Using external auth system
  # Room management handled by Redis (in-memory, TTL-based)
  # ===========================================================================

  # ===========================================================================
  # CACHE/QUEUE - Redis (Simplified for internal use)
  # ===========================================================================
  redis:
    image: redis:7-alpine
    networks:
      - backend
    volumes:
      - redis_data:/data
    command: 
      - redis-server
      - --maxmemory
      - 1gb
      - --maxmemory-policy
      - allkeys-lru
      - --appendonly
      - "yes"
    deploy:
      placement:
        constraints:
          - node.labels.role == manager
      resources:
        limits:
          cpus: '1.0'
          memory: 1500M
        reservations:
          cpus: '0.25'
          memory: 512M
      restart_policy:
        condition: on-failure
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  # ===========================================================================
  # API - FastAPI Backend với SSL
  # ===========================================================================
  api:
    image: jackboun11/jbcalling-api:1.0.0
    networks:
      - frontend
      - backend
    environment:
      # External auth integration (for production)
      - EXTERNAL_AUTH_ENABLED=${EXTERNAL_AUTH_ENABLED:-false}
      - EXTERNAL_AUTH_URL=${EXTERNAL_AUTH_URL:-}
      - JWT_SECRET_KEY=${JWT_SECRET_KEY}
      - JWT_ALGORITHM=${JWT_ALGORITHM}
      - ACCESS_TOKEN_EXPIRE_MINUTES=${ACCESS_TOKEN_EXPIRE_MINUTES}
      - REFRESH_TOKEN_EXPIRE_DAYS=${REFRESH_TOKEN_EXPIRE_DAYS}
      # Demo mode (no auth required)
      - DEMO_MODE=${DEMO_MODE:-true}
      # Redis for room management
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
      - APP_ENV=${APP_ENV}
      - CORS_ORIGINS=https://${DOMAIN_NAME},https://www.${DOMAIN_NAME},https://${API_DOMAIN}
    depends_on:
      - redis
      - traefik
    deploy:
      replicas: 3                     
      placement:
        
        preferences:
          
          - spread: node.labels.instance
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
      labels:
        # Enable Traefik
        - "traefik.enable=true"
        
        # HTTP Router
        - "traefik.http.routers.api.rule=Host(`${API_DOMAIN}`)"
        - "traefik.http.routers.api.entrypoints=websecure"
        - "traefik.http.routers.api.tls.certresolver=letsencrypt"
        - "traefik.http.routers.api.service=api"
        
        # Service
        - "traefik.http.services.api.loadbalancer.server.port=8000"
        - "traefik.http.services.api.loadbalancer.sticky.cookie=true"
        - "traefik.http.services.api.loadbalancer.sticky.cookie.name=api_sticky"
        
        # CORS Middleware
        - "traefik.http.middlewares.api-cors.headers.accesscontrolallowmethods=GET,POST,PUT,DELETE,OPTIONS"
        - "traefik.http.middlewares.api-cors.headers.accesscontrolalloworiginlist=https://${DOMAIN_NAME},https://www.${DOMAIN_NAME}"
        - "traefik.http.middlewares.api-cors.headers.accesscontrolallowheaders=Content-Type,Authorization"
        - "traefik.http.routers.api.middlewares=api-cors"
        
    healthcheck:
      test: ["CMD-SHELL", "python -c 'import urllib.request; urllib.request.urlopen(\"http://localhost:8000/health\")' || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # ===========================================================================
  # SIGNALING - WebSocket Signaling Server với SSL
  # ===========================================================================
  signaling:
    image: jackboun11/jbcalling-api:1.0.0
    networks:
      - frontend
      - backend
    command: ["uvicorn", "signaling:app", "--host", "0.0.0.0", "--port", "8001"]
    environment:
      - APP_ENV=${APP_ENV}
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
    depends_on:
      - redis
      - traefik
    deploy:
      replicas: 3                     
      placement:
        
        preferences:
          
          - spread: node.labels.instance
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      update_config:
        parallelism: 1
        delay: 10s
      labels:
        # Enable Traefik
        - "traefik.enable=true"
        
        # WebSocket Router
        - "traefik.http.routers.signaling.rule=Host(`${WEBRTC_DOMAIN}`)"
        - "traefik.http.routers.signaling.entrypoints=websocket"
        - "traefik.http.routers.signaling.service=signaling"
        
        # Service
        - "traefik.http.services.signaling.loadbalancer.server.port=8001"
        - "traefik.http.services.signaling.loadbalancer.sticky.cookie=true"
        
    healthcheck:
      test: ["CMD-SHELL", "python -c 'import urllib.request; urllib.request.urlopen(\"http://localhost:8001/health\")' || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # ===========================================================================
  # GATEWAY - MediaSoup WebRTC Gateway với STT Streaming
  # ===========================================================================
  gateway:
    image: jackboun11/jbcalling-gateway:1.0.0
    networks:
      - frontend
      - backend
    # ⭐ HOST MODE for WebRTC: Bypass routing mesh, access host UDP ports directly
    ports:
      - target: 3000
        published: 3000
        protocol: tcp
        mode: host  # CRITICAL for MediaSoup WebRTC
    # NOTE: WebRTC UDP/TCP ports (40000-40100) accessed via host network
    # Firewall rules already opened on translation02
    environment:
      # Server
      - PORT=3000
      - HOST=0.0.0.0
      - NODE_ENV=production
      
      # CORS
      - CORS_ORIGIN=https://${DOMAIN},https://${WEBRTC_DOMAIN}
      
      # MediaSoup
      - WORKER_COUNT=2                     # 2 workers (translation02 chỉ có 4 cores, Gateway limit 1 CPU)
      - RTC_MIN_PORT=40000
      - RTC_MAX_PORT=40100
      - ANNOUNCED_IP=34.142.190.250        # translation02 public IP
      - LOG_LEVEL=warn
      
      # Redis (for room state)
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      
      # STT Service
      - STT_SERVICE_URL=http://stt:8001
      - ENABLE_AUDIO_PROCESSING=true
      - AUDIO_SAMPLE_RATE=48000
      - AUDIO_CHANNELS=1
      
    depends_on:
      - redis
      - stt
      - traefik
    deploy:
      mode: global  # ⭐ GLOBAL MODE: 1 replica per node (required for host mode)
      placement:
        constraints:
          - node.labels.instance == translation02  # Deploy on translation02 only
      resources:
        limits:
          cpus: '1.0'                      # Giảm xuống 1 CPU (translation02 chỉ có 4 cores)
          memory: 2G                       # Giảm xuống 2GB RAM (available: 7GB)
        reservations:
          cpus: '0.5'
          memory: 1G
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      update_config:
        parallelism: 1
        delay: 15s
        order: stop-first                  # Stop old before starting new
      labels:
        # Enable Traefik
        - "traefik.enable=true"
        
        # WebSocket Router cho signaling
        - "traefik.http.routers.gateway-ws.rule=Host(`webrtc.jbcalling.site`) && PathPrefix(`/socket.io`)"
        - "traefik.http.routers.gateway-ws.entrypoints=websocket"
        - "traefik.http.routers.gateway-ws.service=gateway"
        - "traefik.http.routers.gateway-ws.tls=true"
        - "traefik.http.routers.gateway-ws.tls.certresolver=letsencrypt"
        
        # HTTP Router cho health/metrics
        - "traefik.http.routers.gateway-http.rule=Host(`webrtc.jbcalling.site`)"
        - "traefik.http.routers.gateway-http.entrypoints=websecure"
        - "traefik.http.routers.gateway-http.service=gateway"
        - "traefik.http.routers.gateway-http.tls=true"
        - "traefik.http.routers.gateway-http.tls.certresolver=letsencrypt"
        
        # Service
        - "traefik.http.services.gateway.loadbalancer.server.port=3000"
        - "traefik.http.services.gateway.loadbalancer.sticky.cookie=true"
        - "traefik.http.services.gateway.loadbalancer.sticky.cookie.name=gateway_affinity"
        
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s                    # Cho MediaSoup workers init

  # ===========================================================================
  # FRONTEND - React Application với SSL
  # ===========================================================================
  frontend:
    image: jackboun11/jbcalling-frontend:1.0.1
    networks:
      - frontend
    environment:
      - VITE_API_URL=https://${API_DOMAIN}
      - VITE_WS_URL=wss://${WEBRTC_DOMAIN}
    depends_on:
      - api
      - signaling
      - traefik
    deploy:
      replicas: 3                     
      placement:
        
        preferences:
          
          - spread: node.labels.instance
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      update_config:
        parallelism: 1
        delay: 10s
      labels:
        # Enable Traefik
        - "traefik.enable=true"
        
        # HTTP Router - catch-all EXCEPT /demo paths
        - "traefik.http.routers.frontend.rule=(Host(`${DOMAIN_NAME}`) || Host(`www.${DOMAIN_NAME}`)) && !PathPrefix(`/demo`)"
        - "traefik.http.routers.frontend.entrypoints=websecure"
        - "traefik.http.routers.frontend.tls.certresolver=letsencrypt"
        - "traefik.http.routers.frontend.service=frontend"
        - "traefik.http.routers.frontend.priority=1"
        
        # Service
        - "traefik.http.services.frontend.loadbalancer.server.port=80"
        
        # Redirect www to non-www
        - "traefik.http.middlewares.redirect-www.redirectregex.regex=^https://www\\.(.+)"
        - "traefik.http.middlewares.redirect-www.redirectregex.replacement=https://$${1}"
        - "traefik.http.middlewares.redirect-www.redirectregex.permanent=true"
        
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost/ || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # ===========================================================================
  # DEMO - Nginx Test Page (Temporary for testing)
  # ===========================================================================
  demo:
    image: nginx:alpine
    networks:
      - frontend
    volumes:
      - type: bind
        source: /home/hopboy2003/jbcalling_translation_realtime/demos
        target: /usr/share/nginx/html
        read_only: true
    deploy:
      replicas: 1
      placement:
        preferences:
          - spread: node.labels.instance
      resources:
        limits:
          cpus: '0.25'
          memory: 128M
        reservations:
          cpus: '0.1'
          memory: 64M
      labels:
        # Enable Traefik
        - "traefik.enable=true"
        
        # HTTP Router - must have HIGHER priority than frontend catch-all
        - "traefik.http.routers.demo-router.rule=(Host(`${DOMAIN_NAME}`) || Host(`www.${DOMAIN_NAME}`)) && PathPrefix(`/demo`)"
        - "traefik.http.routers.demo-router.entrypoints=websecure"
        - "traefik.http.routers.demo-router.tls.certresolver=letsencrypt"
        - "traefik.http.routers.demo-router.service=demo-svc"
        - "traefik.http.routers.demo-router.priority=1000"
        
        # Strip /demo prefix
        - "traefik.http.middlewares.demo-strip.stripprefix.prefixes=/demo"
        - "traefik.http.routers.demo-router.middlewares=demo-strip"
        
        # Service with unique name
        - "traefik.http.services.demo-svc.loadbalancer.server.port=80"
        
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost/ || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # ===========================================================================
  # AI SERVICES - Phase 3
  # ===========================================================================
  
  # ===========================================================================
  # STT - Speech-to-Text Service (Phase 3.1) ✅
  # ===========================================================================
  stt:
    image: jackboun11/jbcalling-stt:streaming-1.0.0  # ⭐ Updated: Streaming endpoints support
    # Graceful shutdown - cho phép container cleanup trước khi kill
    stop_grace_period: 30s
    networks:
      - frontend                      # For Traefik HTTPS routing
      - backend
      - monitoring
    volumes:
      - models_cache:/root/.cache  # Cache cho HuggingFace models
    environment:
      # Model configuration
      - USE_PHOWHISPER=true           # Enable PhoWhisper for Vietnamese
      - USE_FASTER_WHISPER=true       # Enable faster-whisper fallback
      - MODEL_SIZE=medium             # faster-whisper model size (upgraded for better accuracy)
      - COMPUTE_TYPE=int8             # INT8 quantization for CPU
      - DEVICE=cpu                    # CPU-only (no GPU)
      - OMP_NUM_THREADS=4             # CPU threads for inference
      # Performance tuning
      - PYTHONUNBUFFERED=1
      - PYTHONDONTWRITEBYTECODE=1
      # App settings
      - APP_ENV=${APP_ENV:-production}
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
    depends_on:
      - redis
    deploy:
      replicas: 3                     
      placement:
        # Không constraint - cho phép chạy trên cả 3 nodes
        # Swarm tự động spread với preference bên dưới
        preferences:
          
          - spread: node.labels.instance
      resources:
        limits:
          cpus: '2.5'                 # For medium model
          memory: 6G                  # Medium model peak usage
        reservations:
          cpus: '1.0'                 # Reduced from 1.5 to fit 3 replicas on 4-core nodes
          memory: 3G                  # Guaranteed RAM for model
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 5               # Increased from 3 for better resilience
        window: 120s
      update_config:
        parallelism: 1                # Update one replica at a time
        delay: 60s                    # Wait 60s between updates (for model loading)
        order: stop-first             # Stop old before starting new (small downtime OK với 2 replicas)
        failure_action: rollback
        monitor: 90s                  # Monitor for 90s after update
        max_failure_ratio: 0.5        # Rollback if >50% of updates fail
      rollback_config:
        parallelism: 1
        delay: 10s
        failure_action: pause
        monitor: 60s
      labels:
        # Traefik routing for STT service
        - "traefik.enable=true"
        - "traefik.http.routers.stt.rule=Host(`stt.${DOMAIN_NAME}`)"
        - "traefik.http.routers.stt.entrypoints=websecure"
        - "traefik.http.routers.stt.tls.certresolver=letsencrypt"
        - "traefik.http.routers.stt.service=stt"
        - "traefik.http.services.stt.loadbalancer.server.port=8002"
        - "traefik.http.routers.stt.middlewares=stt-cors"
        # Load balancer health check (Traefik-side)
        - "traefik.http.services.stt.loadbalancer.healthcheck.path=/health"
        - "traefik.http.services.stt.loadbalancer.healthcheck.interval=30s"
        - "traefik.http.services.stt.loadbalancer.healthcheck.timeout=20s"  # Match container healthcheck
        # Sticky sessions for consistency (same client → same replica)
        - "traefik.http.services.stt.loadbalancer.sticky.cookie=true"
        - "traefik.http.services.stt.loadbalancer.sticky.cookie.name=stt_server"
        - "traefik.http.services.stt.loadbalancer.sticky.cookie.httponly=true"
        - "traefik.http.services.stt.loadbalancer.sticky.cookie.secure=true"
        # CORS middleware for STT
        - "traefik.http.middlewares.stt-cors.headers.accesscontrolallowmethods=GET,POST,OPTIONS"
        - "traefik.http.middlewares.stt-cors.headers.accesscontrolalloworiginlist=*"
        - "traefik.http.middlewares.stt-cors.headers.accesscontrolallowheaders=*"
        - "traefik.http.middlewares.stt-cors.headers.accesscontrolmaxage=100"
        - "traefik.http.middlewares.stt-cors.headers.addvaryheader=true"
        # Prometheus metrics
        - "prometheus.scrape=true"
        - "prometheus.port=8002"
        - "prometheus.path=/metrics"
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8002/health || exit 1"]
      interval: 30s
      timeout: 20s                    # Tăng lên 20s để xử lý trường hợp model đang load
      retries: 3                      # Cho phép 3 lần thử failed liên tiếp
      start_period: 120s              # Tăng lên 120s (medium model cần ~38s + margin)               # Increased from 60s - allow 90s for dual model loading

  # ===========================================================================
  # TRANSLATION - Multilingual Translation Service (Phase 3.1) ✅ Redis Cache
  # ===========================================================================
  translation:
    image: jackboun11/jbcalling-translation:redis-cache
    networks:
      - frontend                      # For Traefik HTTPS routing
      - backend
      - monitoring
    volumes:
      - models_cache:/root/.cache     # Shared cache with STT
    environment:
      # Model configuration
      - MODEL_NAME=facebook/nllb-200-distilled-600M
      - DEVICE=cpu                    # CPU-only (no GPU)
      - MAX_LENGTH=512                # Max tokens per translation
      - NUM_BEAMS=5                   # Beam search for quality
      # Redis cache configuration
      - REDIS_HOST=redis              # Redis service name
      - REDIS_PORT=6379
      - REDIS_DB=0                    # Database 0 for translation cache
      - REDIS_PASSWORD=               # No password (internal network)
      - CACHE_TTL=86400               # 24 hours cache TTL
      # Performance tuning
      - PYTHONUNBUFFERED=1
      - PYTHONDONTWRITEBYTECODE=1
      - TORCH_NUM_THREADS=4           # CPU threads for PyTorch
      - OMP_NUM_THREADS=4             # OpenMP threads
      # App settings
      - APP_ENV=${APP_ENV:-production}
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
      - PORT=8003
    depends_on:
      - redis
      - stt
    deploy:
      replicas: 1
      placement:
        preferences:
          - spread: node.labels.instance
      resources:
        limits:
          cpus: '2.0'                 # Max 2 CPUs per container
          memory: 4G                  # 4GB RAM (NLLB-200 ~2.5GB model)
        reservations:
          cpus: '1.0'                 # Reserve 1 CPU
          memory: 2G                  # Reserve 2GB RAM (reduced for resource optimization)
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 3
        window: 120s
      update_config:
        parallelism: 1
        delay: 30s
        order: start-first
        failure_action: rollback
      rollback_config:
        parallelism: 1
        delay: 10s
      labels:
        # Traefik routing for Translation service
        - "traefik.enable=true"
        - "traefik.http.routers.translation.rule=Host(`translate.${DOMAIN_NAME}`)"
        - "traefik.http.routers.translation.entrypoints=websecure"
        - "traefik.http.routers.translation.tls.certresolver=letsencrypt"
        - "traefik.http.routers.translation.service=translation"
        - "traefik.http.services.translation.loadbalancer.server.port=8003"
        - "traefik.http.routers.translation.middlewares=translation-cors"
        # CORS middleware for Translation
        - "traefik.http.middlewares.translation-cors.headers.accesscontrolallowmethods=GET,POST,OPTIONS"
        - "traefik.http.middlewares.translation-cors.headers.accesscontrolalloworiginlist=*"
        - "traefik.http.middlewares.translation-cors.headers.accesscontrolallowheaders=*"
        - "traefik.http.middlewares.translation-cors.headers.accesscontrolmaxage=100"
        - "traefik.http.middlewares.translation-cors.headers.addvaryheader=true"
        # Prometheus metrics
        - "prometheus.scrape=true"
        - "prometheus.port=8003"
        - "prometheus.path=/metrics"
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8003/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 90s               # Longer start period for NLLB model loading

  # ===========================================================================
  # TTS - Text-to-Speech Service (Phase 3.1) ✅ Redis Cache
  # ===========================================================================
  tts:
    image: jackboun11/jbcalling-tts:redis-cache
    networks:
      - frontend                      # For Traefik HTTPS routing
      - backend
      - monitoring
    volumes:
      - models_cache:/app/cache       # Cache cho synthesized audio
    environment:
      # TTS Configuration
      - TTS_ENGINE=gtts               # gTTS for fast synthesis (MVP)
      - CACHE_DIR=/app/cache          # Audio cache directory
      # Redis cache configuration
      - REDIS_HOST=redis              # Redis service name
      - REDIS_PORT=6379
      - REDIS_DB=1                    # Database 1 for TTS (DB 0 for translation)
      - REDIS_PASSWORD=               # No password (internal network)
      - CACHE_TTL=86400               # 24 hours cache TTL
      # Performance tuning
      - PYTHONUNBUFFERED=1
      - PYTHONDONTWRITEBYTECODE=1
      # App settings
      - APP_ENV=${APP_ENV:-production}
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
      - PORT=8004
    depends_on:
      - redis
    deploy:
      replicas: 2
      placement:
        preferences:
          - spread: node.labels.instance
      resources:
        limits:
          cpus: '1.0'                 # Max 1 CPU (gTTS is lightweight)
          memory: 1G                  # 1GB RAM (gTTS minimal resources)
        reservations:
          cpus: '0.5'                 # Reserve 0.5 CPU
          memory: 512M                # Reserve 512MB RAM
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 3
        window: 120s
      update_config:
        parallelism: 1
        delay: 20s
        order: start-first
        failure_action: rollback
      rollback_config:
        parallelism: 1
        delay: 10s
      labels:
        # Traefik routing for TTS service
        - "traefik.enable=true"
        - "traefik.http.routers.tts.rule=Host(`tts.${DOMAIN_NAME}`)"
        - "traefik.http.routers.tts.entrypoints=websecure"
        - "traefik.http.routers.tts.tls.certresolver=letsencrypt"
        - "traefik.http.routers.tts.service=tts"
        - "traefik.http.services.tts.loadbalancer.server.port=8004"
        - "traefik.http.routers.tts.middlewares=tts-cors"
        # CORS middleware for TTS
        - "traefik.http.middlewares.tts-cors.headers.accesscontrolallowmethods=GET,POST,OPTIONS"
        - "traefik.http.middlewares.tts-cors.headers.accesscontrolalloworiginlist=*"
        - "traefik.http.middlewares.tts-cors.headers.accesscontrolallowheaders=*"
        - "traefik.http.middlewares.tts-cors.headers.accesscontrolmaxage=100"
        - "traefik.http.middlewares.tts-cors.headers.addvaryheader=true"
        # Prometheus metrics
        - "prometheus.scrape=true"
        - "prometheus.port=8004"
        - "prometheus.path=/metrics"
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8004/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s               # gTTS loads fast (~5-10s)
  # ===========================================================================
  # MONITORING - Prometheus
  # ===========================================================================
  prometheus:
    image: prom/prometheus:latest
    networks:
      - monitoring
      - backend
    volumes:
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=${PROMETHEUS_RETENTION_TIME:-15d}'
    deploy:
      placement:
        constraints:
          - node.labels.role == manager
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M

  # ===========================================================================
  # MONITORING - Grafana với SSL
  # ===========================================================================
  grafana:
    image: grafana/grafana:latest
    networks:
      - monitoring
      - frontend
    volumes:
      - grafana_data:/var/lib/grafana
    environment:
      - GF_SECURITY_ADMIN_USER=${GRAFANA_ADMIN_USER}
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD}
      - GF_SERVER_ROOT_URL=https://${MONITORING_DOMAIN}
      - GF_INSTALL_PLUGINS=redis-datasource
    depends_on:
      - prometheus
      - traefik
    deploy:
      placement:
        constraints:
          - node.labels.role == manager
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
      labels:
        # Enable Traefik
        - "traefik.enable=true"
        
        # HTTP Router
        - "traefik.http.routers.grafana.rule=Host(`${MONITORING_DOMAIN}`)"
        - "traefik.http.routers.grafana.entrypoints=websecure"
        - "traefik.http.routers.grafana.tls.certresolver=letsencrypt"
        - "traefik.http.routers.grafana.service=grafana"
        
        # Service
        - "traefik.http.services.grafana.loadbalancer.server.port=3000"

  # ===========================================================================
  # LOGGING - Loki
  # ===========================================================================
  loki:
    image: grafana/loki:latest
    networks:
      - monitoring
    volumes:
      - loki_data:/loki
    command: -config.file=/etc/loki/local-config.yaml
    deploy:
      placement:
        constraints:
          - node.labels.role == manager
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
